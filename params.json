{"google":"UA-31306748-1","body":"# Backbrace.js\r\n\r\n## Why?\r\nTaller [Backbone](https://github.com/documentcloud/backbone) data sets tend to slouch. Let them stand tall and proud, by allowing for jQueryesque *.live()* calls.\r\n## How?\r\n```html\r\n<!-- http://github.com/pwmckenna/backbrace/ -->\r\n<script type=\"text/javascript\" src=\"backbrace.js\"></script>\r\n```\r\n```js\r\nvar model = new Backbone.Model;\r\nvar callback = function(val) {\r\n  console.log('I only care about d in c in b in a...nothing in between');\r\n};\r\nmodel.live('a b c d', callback);\r\n\r\nmodel.set('a', new Backbone.Model);\r\nmodel.get('a').set('b' new Backbone.Model);\r\nmodel.get('a').get('b').set('c', new Backbone.Model);\r\nmodel.get('a').get('b').get('c').set('d', new Backbone.Model);\r\n\r\n//Your callback was just called!\r\n```\r\n\r\nThis also works when intermediate objects are Collections, though the *id* of the model is used to match the selector, where the attribute key is used for Models.  \r\n__For example:__\r\n```js\r\nvar model = new Backbone.Model;\r\nmodel.live('a b c d', function(e) {\r\n  console.log('I only care about d in c in b in a...and I like using collections');\r\n});\r\n\r\nmodel.set('a', new Backbone.Collection);\r\nmodel.get('a').add(new Backbone.Model({id: 'b'}));\r\nmodel.get('a').get('b').set('c', new Backbone.Collection);\r\nmodel.get('a').get('b').get('c').add(new Backbone.Model({id: 'd'}));\r\n\r\n//Your callback was just called!\r\n```\r\n## Regex?\r\nAlmost. * is supported.  \r\n__For example:__\r\n```js\r\nvar model = new Backbone.Model;\r\nmodel.live('a * c *', function(e) {\r\n  console.log('I care about anything called c, if its in any child attribute/model of a...and I still want to use collections');\r\n});\r\n\r\nmodel.set('a', new Backbone.Collection);\r\nmodel.get('a').add(new Backbone.Model({id: 'b'}));\r\nmodel.get('a').get('b').set('c', new Backbone.Collection);\r\nmodel.get('a').get('b').get('c').add(new Backbone.Model({id: 'd'}));\r\nmodel.get('a').get('b').get('c').add(new Backbone.Model({id: 'e'}));\r\nmodel.get('a').get('b').get('c').add(new Backbone.Model({id: 'f'}));\r\n\r\n//Your callback was just called...three times!\r\n```\r\n__or for a much less contrived example:__\r\n```js\r\nvar collection = new Backbone.Collection;\r\ncollection.live('* name', function(name) {\r\n  console.log('Someone has the name: ' + name);\r\n});\r\n\r\ncollection.add(new Backbone.Model({name: 'Daniel'}));\r\ncollection.add(new Backbone.Model({name: 'Robert'}));\r\ncollection.add(new Backbone.Model({name: 'Mary'}));\r\n\r\n//The following works too!\r\nvar person = new Backbone.Model;\r\ncollection.add(person);\r\nperson.set('name', 'Patrick');\r\n```\r\n## When?\r\nThis is probably not useful if your collections just mirror flat database tables. However, if you are using something like [BitTorrent's btapp library](http://github.com/pwmckenna/btapp/), it tends to be a struggle to cleanly interact with a tree of Backbone models and collections that grows to be quite deep. In most cases, you're only interested in the leaves of the tree, and this is an attempt to simplify that experience.  \r\n\r\n\r\nTo borrow an example from the [aforementioned btapp library](http://github.com/pwmckenna/btapp/), imagine a root object, that has a collection of torrents, which each contain a list of files, which have a properties attribute, which itself is chocked full of key value pairs. If we wanted a simple way to create a Backbone.View for each of these files' properties objects, we might do the following:\r\n```js\r\nvar btapp = new Btapp;\r\nbtapp.live('torrent * file * properties', function(properties) {\r\n  var view = new FilePropertiesView({model: properties});\r\n  $('#files').append(view.render().el);\r\n});\r\n```\r\n## Testing\r\n![travis](https://secure.travis-ci.org/pwmckenna/backbrace.png)  \r\nTests are written using [jasmine](https://github.com/pivotal/jasmine).  \r\nContinuous Integration provided by [Travis CI](http://travis-ci.org/#!/pwmckenna/backbrace)...Thanks guys!  \r\nTo run the test suite yourself, open *spec/SpecRunner.html* in a browser.  \r\n\r\n\r\n## Todo\r\n- Support idAttribute\r\n- Support id changes\r\n\r\n## Feedback\r\nI'd love feedback. [@pwmckenna](https://twitter.com/#!/pwmckenna)\r\n\r\n<br><br>\r\nSpecial thanks to Andrew de Andrade ([@andrewdeandrade](https://twitter.com/#!/andrewdeandrade)) for the inspiration!\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Give your backbone app some support when dealing with tall trees of data.","name":"Backbrace"}